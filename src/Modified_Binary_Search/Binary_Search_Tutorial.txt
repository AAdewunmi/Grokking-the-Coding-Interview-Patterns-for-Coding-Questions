Modified Binary Search
=============

- Introduction:

Binary Search is the most popular Searching Algorithm which is most asked in coding interviews.
Its popularity is because of it’s time complexity, where the linear search algorithm takes O(N) time, the Binary Search
takes O(log N) time. The only condition in Binary Search is that the array should be sorted.
However, there’s a modified version of binary search that comes in handy when we’re dealing with specific situations.
(Ref: Ashutosh Kumar, Modified Binary Search Algorithm to Solve Tricky Problems. Medium (Sept, 22, 2020))

- Here are some common scenarios where modified binary search is employed:

      1. Search for the First or Last Occurrence:
          In a sorted array, instead of finding just any occurrence of a target value, you may need to find the
          first or last occurrence of that value. This can be done by adjusting the conditions for updating the search
          boundaries.

      2. Search in a Rotated Sorted Array:
          When an array is sorted and then rotated, a modified binary search can efficiently find a target value.
          The search algorithm must determine which portion of the array is sorted to decide how to update the search
          boundaries.

      3. Finding Peak Element in an Array:
          In an array where elements first increase and then decrease, a modified binary search can be used to find
          the peak element.

      4. Finding Minimum in a Rotated Sorted Array:
          In a rotated sorted array, a modified binary search can find the minimum element by identifying the point
          of rotation.

      5. Search for a Closest Value:
          When looking for the closest value to a target in a sorted array, binary search can be modified to keep track
          of the closest value found during the search.

- Examples of Modified Binary Search

*** LeetCode Question: 33. Search in Rotated Sorted Array

There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length)
such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed).
For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums,
or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

- Solution

public class RotatedSortedArraySearch {

    public int search(int[] nums, int target) {
        int low = 0, high = nums.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (nums[mid] == target) {
                return mid;
            }

            // Check if the left side is sorted
            if (nums[low] <= nums[mid]) {
                // Target is in the left half
                if (nums[low] <= target && target < nums[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            // Right side must be sorted
            else {
                // Target is in the right half
                if (nums[mid] < target && target <= nums[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }

        // Target not found
        return -1;
    }

    public static void main(String[] args) {
        RotatedSortedArraySearch searcher = new RotatedSortedArraySearch();
        int[] nums = {4, 5, 6, 7, 0, 1, 2};
        int target = 0;
        int result = searcher.search(nums, target);
        System.out.println("Index of target: " + result); // Output: 4
    }
}

Explanation:

    Initial Setup:
        Initialize two pointers, low and high, to the start and end of the array.

    Binary Search Loop:
        While low is less than or equal to high:
            Compute the middle index mid.
            If nums[mid] is the target, return mid.

    Determine Sorted Half:
        If the left half (nums[low] to nums[mid]) is sorted:
            Check if the target is within the range of the sorted half. If it is, adjust the high pointer to mid - 1.
            Otherwise, adjust the low pointer to mid + 1.
        If the right half (nums[mid] to nums[high]) is sorted:
            Check if the target is within the range of the sorted half. If it is, adjust the low pointer to mid + 1.
            Otherwise, adjust the high pointer to mid - 1.

    Target Not Found:
        If the loop exits, it means the target is not in the array. Return -1.

This algorithm ensures O(log n) runtime complexity by effectively narrowing down the search space by half during each
iteration of the loop.